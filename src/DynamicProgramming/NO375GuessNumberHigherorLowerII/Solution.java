package DynamicProgramming.NO375GuessNumberHigherorLowerII;

/**
 * ------------笔记---------
 * 动态规划区别暴力计算(没有记忆（缓存）的分支策略)：动态规划的dp会记录下子问题的结果 给上一层使用
 * 而没有使用缓存的分支递归 会有很多重复的子问题重复计算
 * <p>
 * 题意：我们的搜索策略能够确定所有的值（也就是间隔确定 例如 1 2 3 4 5 找到 2 4那么所有值全部都能确定 此开销（最大开销值 2+4）
 * 找到3 1 4也能确定所有值 此时最大开销为 3->4>3->1 最大开销（带够）7则可
 * 在我们的搜索策略中的开销（最大开销值中） 我们要选择最小的最大开销值
 */
public class Solution {

    public static void main(String[] args) {
        System.out.println(new Solution().getMoneyAmount(5));
    }

    /**
     * 动态规划找准状态与状态转移的技巧：状态必须是由子状态加当前操作组成 这里的k也就是当前选k时要消耗k
     * 如果我们想着用找到数i所需要的最少消耗与找到j的最少消耗组成l 那么当前选一个数k猜的这个步骤与子状态毫无关系
     *
     * @param n
     * @return
     */
    public int getMoneyAmount(int n) {
        int[][] dp = new int[n + 1][n + 1];
        //子问题规模为1 那选的数就是当前的数 开销dp[i][i]为0
        for (int i = 2; i <= n; i++) {
            //子问题枚举
            for (int j = 1; j <= n - i + 1; j++) {
                //求解当前子问题值 枚举k值
                //我们是要找枚举k值中的最小开销值（这个最小开销值才是我们认为的最优找法（二分找法 但是也不一定都是找中间那个数开销最小 比如 1 2 3 4 5 找3再找4 比找2再找4开销大 但绝对不会从1开始找！！！））
                //二分找法中 我们要保证我们一定能赢 就必须带够钱 那么我们需要考虑二分找法的最大开销 因此要选择左子问题和右子问题中开销最大的
                //-------------减少无用的枚举-----------//
                //我们从中点开始dp[i][j] (i+j)/2（向下取整 并且1到n是递增） 那么右侧区间元素数量一定大于等于左边区间（多1）
                //右侧区间元素值也大于左侧区间元素值 所以在中点之前的枚举情况 我们都直接选择的右侧最多值
                //我们当前状态是要求得枚举值中最小的值 那么 我们右侧区间与左侧区间的开销相差不能过大 因此我们从中点向右侧hop
                //让左侧值增大 右侧值减小 来保证两个区间开销更接近 总体开销更小
                //------------思考-----------//
                //从中间往右侧移动 当出现总体开销由变小到变大的拐点时 是否能保证之后的总体开销都是增大(二次抛物线的拐点)
                //证明： 首先我们能肯定 dp[i][i+5]与dp[i][i+4]肯定是区间越大的消耗越大
                //            dp[j-5][j]与dp[j-4][j]同理 也就是说 从中间点开始 我们的中间点在二次曲线拐点左侧  然后到拐点右侧
                //
                int lastOne = j + i - 1;
                int minNum = Integer.MAX_VALUE;
                //int count = 0;
                //不可能存在k枚举到lastOne的情况 k<lastOne 也防止了数组越界
                //---------------思考：对于 1 2 3 4 5中 2 4组合是最小的开销  但是我们中点是3 这会不会跳过2这个元素的寻找？
                //并不会 因为从3开始向右边枚举的过程中 会有4的情况 此时就会吧左侧的 1 2 3的2算入
                for (int k = (j + lastOne) / 2; k < lastOne; k++) {
                    //int res=0;
                    //if(k==j){ 当 2 3 选择2这种情况（k==j时）我们不需要单独讨论 因为dp[j][j-1](矩阵左下角元素都为0 不影响结果)
                    //    res=k+dp[k+1][lastOne];          dp[j+1=lastOne][lastOne]=0同样也不影响结果
                    //}else{
                    int res = k + Math.max(dp[j][k - 1], dp[k + 1][lastOne]);
                    //}
                    if (res < minNum) {
                        minNum = res;
                        dp[j][lastOne] = res;
                    } /*else if (res > minNum) {
                        count++;
                        if (count == 2) {
                            break;
                        }
                    }*/
                    //不可行 不是严格二次曲线！！！！！！！！！！！！！！！！
                }
            }
        }
        return dp[1][n];
    }

}
